# Общая информация

STACK: **`Django`**,  **`PostgreSQL`**,  **`Django REST Framework`**

Проект из себя представляет веб-приложение для кафетерия для управления заказами с поддержкой REST. Поведение некоторых REST методов может отличаться от поведения REST методов в стандартных веб-приложениях. Перед использованием мстоит ознакомиться с руководством по API методам.

## Запуск  
### Предварительные действия  
#### Переменные окружения  
Перед запуском приложения необходимо определить следующие переменные окружения:  
- **SECRET_KEY** - секретный ключ  
- **POSTGRES_DB** - название базы данных в PostgreSQL  
- **POSTGRES_USER** - имя пользователя, который имеет доступ к базе данных  
- **POSTGRES_PASSWORD** - пароль пользователя базы данных в PostgreSQL  
- **POSTGRES_HOST** - адрес работающей базы данных PostgreSQL  
- **DEBUG** - флаг включенной или выключенной отладки(1 или 0)
### Варианты запуска  
#### Обычный запуск  
Для обычного запуска достаточно ввести последовательность следующих команд в директории проекта:  
1. `pip install -r requirements.txt`  
2. `python manage.py makemigrations`  
3. `python manage.py migrate`  
4. `python manage.py runserver`  
#### Запуск через docker  
Для запуска через docker понадобится лишь создать в директории проекта файл переменных окружения **vars.env** и прописать там все необходимые переменные окружения.
Далее все запускается командой `docker-compose up` в директории проекта.
#### Создание блюд
Далее следует создать суперпользователя командой:
`python manage.py createsuperuser`
и с помощью админ панели по адресу `/admin` создать в базе данных записи с блюдами в разделе **Dishes**. Дальше можно пользоваться интерфейсом приложения.

## Тестирование
В проекте реализовано тестирование. Оно запускается командой `python manage.py test` при настроенных переменных окружения и выданной пользователю базы данных привилегии создавать базы данных.

# Структура

## Роутинг

Все начинается с маршрутизации запросов. Она работает по принципу поочередного делегирования запроса дочернему URL-конфигу. В базовом URL-конфиге производится роутинг на URL-конфиг разделов приложений, находящийся по пути: **(имя раздела)/urls/base**. Дальше происходит роутинг на URL-конфиг  1 из 2 видов способа представления информации пользователю: **API** и **веб-интерфейс в виде HTML страниц**. А потом происходит роутинг на функции или классы представлений. Общая схема роутинга выглядит следующим образом:

**приложение определяет, к какому разделу отправлен запрос** --> **приложение определяет, какой способ представления запрошен в запросе** --> **приложение определяет, какое представление запрошено в запросе**

## Представление информации

Представления в приложении делятся на 2 типа: представление через REST API и представление через страничный веб-интерфейс. Их функционал выполняют классы и функции представлений. Для простоты дальше они будут называться **views** . Все **views** используют те или иные инструменты представления, которые, соответственно представлениям, делятся на 2 типа: страничные и API. Инструменты представления для страничного веб-интерфейса - это HTML шаблоны, CSS и JS файлы, а инструменты представления для API - это сериализаторы. Все инструменты представления хранятся в **view_tools** в общей директории проекта. **views** файлы находятся в директории **views/** в каждом разделе приложения.

## Бизнес логика

Вся бизнес логика приведена в пакете **services** в каждом разделе приложения.

## Разделение приложения

Приложение разделено на несколько частей, каждая из которых выполняет свою часть бизнес логики приложения. Эти части далее будут называться "разделы".

- **Orders** - раздел управления заказами

# Веб-интерфейс, заказы

## Вывод
### Как реализовано
Вывод заказов реализован через встроенный в Django шаблон классов представлений **ListView**. Из дополнений были реализованы только передача текущего статуса для инструментов фильтрации и фильтрация списка объектов по переданным представлению фильтрам. За отображение страницы вывода отвечает класс **OrdersListView** в файле **views.py**.
### Как пользоваться
Вывод заказов происходит на странице **Поиск заказов**. На этой странице реализовано 2 инструмента поиска: по фильтру и по номеру стола. Фильтры реализованы с использованием **GET** параметров.

## Добавление заказа
### Как реализовано
Добавление заказа было реализовано через встроенные в Django шаблон классов представлений **FormView** и шаблон классов форм **ModelForm**. Из дополнений были реализованы только передача текущего статуса для инструментов фильтрации и фильтрация списка объектов по переданным представлению фильтрам. Все было реализовано в рамках официальной документации **Django** без дополнений со стороны разработчика. За отображение страницы добавления заказа отвечает класс **CreateOrderView** в файле **views.py**. За отображение формы создания заказа отвечает класс **OrderCreateForm** в файле **forms.py**
### Как пользоваться
Добавление заказа реализовано через обычную форму на странице **Добавление заказа**, все как обычно.

## Расчёт выручки
### Как реализовано
Расчёт выручки реализован через простую функцию-представление **calc_cash** и функцию, предоставляющей API для Ajax запроса на странице подсчёта выручки **get_cash**
### Как пользоваться
Расчёт выручки выполняется на странице **Расчёт выручки**: достаточно просто выставить промежуток времени, за который надо подсчитать выручку.

## Редактирование заказа
### Как реализовано
#### Удаление заказа
Удаление заказа реализовано через простую функцию-представление **delete_order**, в которую через строку запроса передается идентификатор удаляемого заказа

#### Изменение деталей заказа
Изменение деталей заказа, подобно **Добавлению заказа**, реализовано через шаблон классов представлений **UpdateView** и шаблона классов формы **ModelForm**. Из дополнения в классе представления реализовано только задавание даты оплаты в зависимости от предыдущего статуса и изменение дефолтной формы для изменения объекта модели. В остальном поведение класса-представление стандартно.

### Как пользоваться
#### Удаление заказа
Удаление заказов выполняется через нажатие на клавишу **Удалить** справа от каждой записи о заказе.

#### Изменение деталей заказа
Редактирование заказа выполняется через страницу с формой редактирования заказа при нажатии на кнопку **Редактировать** справа от каждой записи о заказе.

# REST API, заказы

## Получение сведений о заказах

### GET
Для получения информации о заказах стоит отправить **POST** или **GET** запрос на адрес **/orders/api/retrieve/**.

### POST
**POST** запрос принимает параметры, по которым будет проводится фильтр заказов и возвращает все заказы, прошедшие этот фильтр. В случае, если в базе данных нет ни одного объекта, который соответствует указанным в теле запроса значениям, будет возвращен ответ с кодом 404. Передача в тело поля **items** будет означать поиск всех заказов, в составе которых есть хотя бы 1 блюдо, идентификатор которого был в списке, который был задан полем **items**. Ниже приведен пример запроса и ответа:

```
REQUEST_BODY
{
"items": [8]
}
```

```
RESPONSE_BODY
[{"id":24,"table_number":3,"status":3,"paid_date":null,"items":[{"id":8,"name":"TESTDISH1","price":150},{"id":9,"name":"TESTDISH2","price":200},{"id":10,"name":"TESTDISH3","price":250},{"id":11,"name":"TESTDISH4","price":300}]},

{"id":34,"table_number":16,"status":2,"paid_date":null,"items":[{"id":8,"name":"TESTDISH1","price":150},{"id":7,"name":"Курица","price":300}]}]
```

## Редактирование, создание и удаление заказов

### POST
**POST** запрос создает заказ. В теле запроса стоит указать лишь поля, с которыми будет создан заказ в базе данных. В случае нарушения бизнес-правил или некорректном вооде данных будет возвращен ответ со статусом 400 и текстом, уточняющим ошибку ввода. Ниже приведен пример запроса:

```
REQUEST_BODY
{
"table_number": 14,
"items": [7]
}
```

### PUT
**PUT** запрос вносит изменения в базу данных. Для этого в тело ответа передаются 2 словаря: **select** и **update**.
- **select** - словарь, по которому выполняется выборка объектов, которые будут изменены
- **update** - словарь, по которому будут заданы значения отобранным объектам
Ниже приведен пример запроса:

```
REQUEST_BODY
{
"select": {
	"status": 1
},
"update": {
	"status": 2,
	"paid_date": null
	}
}
```

### DELETE
**DELETE** метод удаляет все объекты, соответсвующие введенной выборке. Входные данные идентичны входным данным для **retrieve** операций. В результате выполнения все отобранные объекты будут удалены.